Last Stand Tower Defense
David Setiawan

Changes from proposal:
In terms of the general game, I decided to allow towers to be placed only on block tiles. I also decided to give enemies no attacking abilities (i.e. they simply move). The general design of the game should be the about the same as the one outlined in the proposal. 

2D Arrays:
I used 2D arrays to hold my Tiles. The Tiles class holds information including where it is positioned (x, y), what type of block it is (open or block), what tower, if any, are placed on it, and many more states. The use of a 2D array made it easier to keep track of tile positioning, especially when it came to mouse click events where the position of the click event is important. I also used 2D arrays to keep track of high scores (name and score for each entry) when needed. I initially used a Map but realized that Maps don't allow duplicate keys. This meant that if I represented keys as names, then there would be an issue when people used the same name. On the other hand, if I represented keys as scores, then there would be an issue when people had the same scores. For this reason, I decided to go with a 2D array, which allowed duplicates. 

Collections:
I used collections quite a lot in this game and have learned about the importance of .equals and .compareTo the hard way (the source of most of my bugs originated from the failure of collections to add or remove certain elements, which confused me for days). My first use of collections was in my pathfinder class to find paths in the randomly generated game map. The paths were stored as LinkedList because order of tiles in the path matters and LinkedLists allowed for simpler traversal. 
Most of my other collections are TreeSets because I needed to store various objects and it seemed to be the easiest and most logical to implement. One important use of the TreeSet was to allow towers to target the first enemy on the path. I implemented the Comparable class in the Enemy class and designed compareTo in such a way that enemies in TreeSet<Enemy> would be ordered from those having made least progress in their path to those having the most progress. Then, towers could simply, from the enemies within their range, target those that were last in the TreeSet (i.e. the one that has made the most progress). I also used TreeSets to store data about which towers, enemies, and projectiles are active on the game map. 

File I/O:
I used File I/O for a top 10 highest scores feature. The File I/O would write scores to a txt file and read them when they need to be displayed. The file reader was designed to read each line and look for lines of text that are separated by only one whitespace (all other Strings are filtered out). Hence, the whitespace separates a player's name and their scores (in that order). Moreover, when a player achieves a score higher than the 10th highest score, their name will be requested and their name and score will be displayed on the high scores panel. At the same time, the text file will be updated and rewritten. If players do not input their name, the default name will be "PLAYER".

Inheritance/Subtyping for Dynamic Dispatch
My main use of subtyping and inheritence is in my Tower hierarchy. Tower is the supertype of all other tower classes. Each Tower subclass (other than abstract classes) implements the five levels methods. These methods describe the different upgrades that a player can have. Since each tower does something unique, they will need different levels methods. Moreover, the upgrade method is housed in the Tower class. Thus, any subclass of Tower that wants to upgrade will use the Tower class upgrade method, which is an example of Dynamic Dispatch. On the next level of the Tower hierarchy are RangeTower and FarmTower. FarmTower is a class that extends Tower while RangeTower is an abstract class that extends Tower. FarmTower is simply a tower that gives the player an extra coins every 5 seconds. It is unique than the other towers in that it contains a timer that executes a pay method every 5 seconds (pay method pays a certan extra amount of coins to the player). The RangeTower abstract class is for towers that require range capabilities. That is, towers that need to detect nearby enemies. This class is equipped with a unique target data field and a enemiesWithinRange method that returns a TreeSet<Enemy> with enemies in order from least progressed to most progressed (as explained previously). The AttackTower abstract class extends the RangeTower abstract class. This class is for towers that use projectiles in some way. This class contains the unique towerEngage method that allows the tower to shoot at enemies that are nearby. As of now, there are only two classes that extend the AttackTower abstract class: the ShooterTower and SniperTower classes. These classes function similarly but have different levels methods and different data fields. In the GameMap class, a timer moves the animations forward. Every time the timer ticks, various events occur, including the calling of the towerEngage class for AttackTower instances (any ShooterTower or SniperTower). This is another example of dynamic dispatch. There are many more examples, but these were one of the most important uses. 